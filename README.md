
[![Travis](https://img.shields.io/travis/williamfiset/Algorithms.svg)](https://travis-ci.org/williamfiset/Algorithms) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

# Dynamic Programming
* [Coin change problem](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/CoinChange.java) **- O(nW)**
* [Edit distance](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/EditDistance.java) **- O(nm)**
* [Knapsack 0/1](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/Knapsack_01.java) **- O(nW)**
* [Knapsack unbounded (0/∞)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/KnapsackUnbounded.java) **- O(nW)**
* [Maximum contiguous subarray](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/MaximumSubarray.java) **- O(n)**
* [Longest Common Subsequence (LCS)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/LongestCommonSubsequence.java) **- O(nm)**
* [Longest Increasing Subsequence (LIS)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/LongestIncreasingSubsequence.java) **- O(n<sup>2</sup>)**
* [Longest Palindrome Subsequence (LPS)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/dp/LongestPalindromeSubsequence.java) **- O(n<sup>2</sup>)**
* [Traveling Salesman Problem (dynamic programming, iterative)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/graphtheory/TspDynamicProgrammingIterative.java) **- O(n<sup>2</sup>2<sup>n</sup>)**
* [Traveling Salesman Problem (dynamic programming, recursive)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/graphtheory/TspDynamicProgrammingRecursive.java) **- O(n<sup>2</sup>2<sup>n</sup>)**

# Geometry
* [Angle between 2D vectors](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/AngleBetweenVectors2D.java) **- O(1)**
* [Angle between 3D vectors](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/AngleBetweenVectors3D.java) **- O(1)**
* [Circle-circle intersection point(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/CircleCircleIntersectionPoints.js) **- O(1)**
* [Circle-line intersection point(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LineCircleIntersection.js) **- O(1)**
* [Circle-line segment intersection point(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LineSegmentCircleIntersection.js) **- O(1)**
* [Circle-point tangent line(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/PointCircleTangent.java) **- O(1)**
* [Closest pair of points (line sweeping algorithm)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/ClosestPairOfPoints.java) **- O(nlog(n))**
* [Collinear points test (are three 2D points on the same line)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/CollinearPoints.java) **- O(1)**
* [Convex hull (Graham Scan algorithm)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/ConvexHullGrahamScan.java) **- O(nlog(n))**
* [Convex hull (Monotone chain algorithm)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/ConvexHullMonotoneChainsAlgorithm.java) **- O(nlog(n))**
* [Convex polygon area](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/ConvexPolygonArea.java) **- O(n)**
* [Convex polygon cut](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/ConvexPolygonCutWithLineSegment.java) **- O(n)**
* [Convex polygon contains points](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/ConvexPolygonContainsPoint.java) **- O(log(n))**
* [Coplanar points test (are four 3D points on the same plane)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/CoplanarPointsTest.java) **- O(1)**
* [Line class (handy infinite line class)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/Line.java) **- O(1)**
* [Line-circle intersection point(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LineCircleIntersection.js) **- O(1)**
* [Line segment-circle intersection point(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LineSegmentCircleIntersection.js) **- O(1)**
* [Line segment to general form (ax + by = c)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LineSegmentToGeneralForm.java) **- O(1)**
* [Line segment-line segment intersection](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LineSegmentLineSegmentIntersection.java) **- O(1)**
* [Longitude-Latitude geographic distance](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/LongitudeLatitudeGeographicDistance.java) **- O(1)**
* [Point-circle tangent line(s)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/PointCircleTangent.java) **- O(1)**
* [Point is inside triangle check](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/PointInsideTriangle.java) **- O(1)**
* [Point rotation about point](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/PointRotation.java) **- O(1)**
* [Triangle area algorithms](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/TriangleArea.java) **- O(1)**
* [[UNTESTED] Circle-circle intersection area](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/CircleCircleIntersectionArea.java) **- O(1)**
* [[UNTESTED] Circular segment area](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Geometry/CircularSegmentArea.java) **- O(1)**

# Graph theory

### Tree algorithms
* [Tree diameter](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TreeAlgorithms/TreeDiameter.java) **- O(V+E)**
* [Tree canonical form](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TreeAlgorithms/TreeCanonicalFormAdjacencyList.java) **- O(V+E)**

### Network flow
* [Bipartite graph verification (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/NetworkFlow/BipartiteGraphCheckAdjacencyList.java) **- O(V+E)**
* [Ford-Fulkerson method with DFS (max flow, min cut, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/NetworkFlow/FordFulkersonDFSAdjacencyList.java) **- O(fE)**
* [Ford-Fulkerson method with DFS (max flow, min cut, adjacency matrix)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/NetworkFlow/FordFulkersonDFSAdjacencyMatrix.java) **- O(fV<sup>2</sup>)**
* [Edmonds-Karp Algorithm (max flow, min cut, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/NetworkFlow/EdmondsKarpAdjacencyList.java) **- O(VE<sup>2</sup>)**
* [Edmonds-Karp Algorithm optimized (max flow, min cut, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/NetworkFlow/EdmondsKarpAdjacencyListOptimized.java) **- O(VE<sup>2</sup>)**
* [Maximum Cardinality Bipartite Matching (augmenting path algorithm, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/NetworkFlow/MaximumCardinalityBipartiteMatchingAugmentingPathAdjacencyList.java) **- O(VE)**

### Other graph theory
* [Articulation points/cut vertices (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/ArticulationPointsAdjacencyList.java) **- O(V+E)**
* [Bellman-Ford (edge list, negative cycles)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/BellmanFordEdgeList.java) **- O(VE)**
* [Bellman-Ford (adjacency list, negative cycles)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/BellmanFordAdjacencyList.java) **- O(VE)**
* [Bellman-Ford (adjacency matrix, negative cycles)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/BellmanFordAdjacencyMatrix.java) **- O(V<sup>3</sup>)**
* [Breadth first search (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/BreadthFirstSearchAdjacencyListIterative.java) **- O(V+E)**
* [Breadth first search (adjacency list, fast queue)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/BreadthFirstSearchAdjacencyListIterativeFastQueue.java) **- O(V+E)**
* [Bridges/cut edges (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/BridgesAdjacencyList.java) **- O(V+E)**
* [Find connected components (adjacency list, union find)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/ConnectedComponentsAdjacencyList.java) **- O(Elog(E))**
* [Find connected components (adjacency list, DFS)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/ConnectedComponentsDfsSolverAdjacencyList.java) **- O(V+E)**
* [Depth first search (adjacency list, iterative)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/DepthFirstSearchAdjacencyListIterative.java) **- O(V+E)**
* [Depth first search (adjacency list, iterative, fast stack)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/DepthFirstSearchAdjacencyListIterativeFastStack.java) **- O(V+E)**
* [Depth first search (adjacency list, recursive)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/DepthFirstSearchAdjacencyListRecursive.java) **- O(V+E)**
* [Dijkstra's shortest path (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/DijkstrasShortestPathAdjacencyList.java) **- O(Elog(V))**
* [Dijkstra's shortest path to all nodes (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/DijkstrasShortestPathAllNodesAdjacencyList.java) **- O(Elog(V))**
* [Floyd Warshall algorithm (adjacency matrix, negative cycle check)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/FloydWarshallSolver.java) **- O(V<sup>3</sup>)**
* [Graph diameter (adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/GraphDiameter.java) **- O(VE)**
* [Kruskal's min spanning tree algorithm (edge list, union find)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/KruskalsEdgeList.java) **- O(Elog(E))**
* [Prim's min spanning tree algorithm (lazy version, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/LazyPrimsAdjacencyList.java) **- O(Elog(E))**
* [Prim's min spanning tree  algorithm (lazy version, adjacency matrix)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/LazyPrimsAdjacencyMatrix.java) **- O(V<sup>2</sup>)**
* [Prim's min spanning tree  algorithm (eager version, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/EagerPrimsAdjacencyList.java) **- O(Elog(V))**
* [Steiner tree (minimum spanning tree generalization)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/SteinerTree.java) **- O(V<sup>3</sup> + V<sup>2</sup> * 2<sup>T</sup> + V * 3<sup>T</sup>)**
* [Tarjan's strongly connected components algorithm (adjacency list) ](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TarjanSccSolverAdjacencyList.java) **- O(V+E)**
* [Tarjan's strongly connected components algorithm (adjacency matrix) ](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TarjanAdjacencyMatrix.java) **- O(V<sup>2</sup>)**
* [Topological sort (acyclic graph, adjacency list)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TopologicalSortAdjacencyList.java) **- O(V+E)**
* [Topological sort (acyclic graph, adjacency matrix)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TopologicalSortAdjacencyMatrix.java) **- O(V<sup>2</sup>)**
* [Traveling Salesman Problem (brute force)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TspBruteForce.java) **- O(n!)**
* [Traveling Salesman Problem (dynamic programming, iterative)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TspDynamicProgrammingIterative.java) **- O(n<sup>2</sup>2<sup>n</sup>)**
* [Traveling Salesman Problem (dynamic programming, recursive)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/TspDynamicProgrammingRecursive.java) **- O(n<sup>2</sup>2<sup>n</sup>)**

# Linear algebra
* [Freivald's algorithm (matrix multiplication verification)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/FreivaldsAlgorithm.java) **- O(kn<sup>2</sup>)**
* [Gaussian elimination (solve system of linear equations)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/GaussianElimination.java) **- O(cr<sup>2</sup>)**
* [Gaussian elimination (modular version, prime finite field)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/ModularLinearAlgebra.java) **- O(cr<sup>2</sup>)**
* [Linear recurrence solver (finds nth term in a recurrence relation)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/LinearRecurrenceSolver.java) **- O(m<sup>3</sup>log(n))**
* [Matrix determinant (Laplace/cofactor expansion)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/MatrixDeterminantLaplaceExpansion.java) **- O((n+2)!)**
* [Matrix inverse](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/MatrixInverse.java) **- O(n<sup>3</sup>)**
* [Matrix multiplication](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/MatrixMultiplication.java) **- O(n<sup>3</sup>)**
* [Matrix power](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/MatrixPower.java) **- O(n<sup>3</sup>log(p))**
* [Square matrix rotation](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/LinearAlgebra/RotateSquareMatrixInplace.java) **- O(n<sup>2</sup>)**

# Mathematics
* [Chinese remainder theorem](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/ChineseRemainderTheorem.java)
* [Prime number sieve (sieve of Eratosthenes)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/SieveOfEratosthenes.java) **- O(nlog(log(n)))**
* [Prime number sieve (sieve of Eratosthenes, compressed)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/CompressedPrimeSieve.java) **- O(nlog(log(n)))**
* [Totient function (phi function, relatively prime number count)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/EulerTotientFunction.java) **- O(n<sup>1/4</sup>)**
* [Totient function using sieve (phi function, relatively prime number count)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/EulerTotientFunctionWithSieve.java) **- O(nlog(log(n)))**
* [Extended euclidean algorithm](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/ExtendedEuclideanAlgorithm.java) **- ~O(log(a + b))**
* [Greatest Common Divisor (GCD)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/GCD.java) **- ~O(log(a + b))**
* [Fast Fourier transform (quick polynomial multiplication)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/FastFourierTransform.java) **- O(nlog(n))**
* [Fast Fourier transform (quick polynomial multiplication, complex numbers)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/FastFourierTransformComplexNumbers.java) **- O(nlog(n))**
* [Primality check](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/IsPrime.java) **- O(√n)**
* [Primality check (Rabin-Miller)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/RabinMillerPrimalityTest.py) **- O(k)**
* [Least Common Multiple (LCM)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/LCM.java) **- ~O(log(a + b))**
* [Modular inverse](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/ModularInverse.java) **- ~O(log(a + b))**
* [Prime factorization (pollard rho)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/PrimeFactorization.java) **- O(n<sup>1/4</sup>)**
* [Relatively prime check (coprimality check)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/Math/RelativelyPrime.java) **- ~O(log(a + b))**

# Other
* [Bit manipulations](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/BitManipulations.java) **- O(1)**
* [List permutations](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/Permutations.java) **- O(n!)**
* [Power set (set of all subsets)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/PowerSet.java) **- O(2<sup>n</sup>)**
* [Set combinations](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/Combinations.java) **- O(n choose r)**
* [Set combinations with repetition](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/CombinationsWithRepetition.java) **- O((n+r-1) choose r)**
* [Sliding Window Minimum/Maximum](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/SlidingWindowMaximum.java) **- O(1)**
* [Square Root Decomposition](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/SquareRootDecomposition.java) **- O(1) point updates, O(√n) range queries**
* [Unique set combinations](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/other/UniqueCombinations.java) **- O(n choose r)**

# Search algorithms
* [Binary search (real numbers)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/search/BinarySearch.java) **- O(log(n))**
* [Interpolation search (discrete discrete)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/search/InterpolationSearch.java) **- O(n) or O(log(log(n))) with uniform input**
* [Ternary search (real numbers)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/search/TernarySearch.java) **- O(log(n))**
* [Ternary search (discrete numbers)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/search/TernarySearchDiscrete.java) **- O(log(n))**

# Sorting algorithms
* [Bubble sort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/BubbleSort.java) **- O(n<sup>2</sup>)**
* [Bucket sort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/BucketSort.java) **- Θ(n + k)**
* [Counting sort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/CountingSort.java) **- O(n + k)**
* [Heapsort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/Heapsort.java) **- O(nlog(n))**
* [Insertion sort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/InsertionSort.java) **- O(n<sup>2</sup>)**
* [Mergesort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/Mergesort.java) **- O(nlog(n))**
* [Quicksort (in-place, Hoare partitioning)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/Quicksort.java) **- Θ(nlog(n))**
* [Selection sort](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/sorting/SelectionSort.java) **- O(n<sup>2</sup>)**

# String algorithms
* [Booth's algorithm (finds lexicographically smallest string rotation)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/BoothsAlgorithm.java) **- O(n)**
* [Knuth-Morris-Pratt algorithm (finds pattern matches in text)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/KMP.java) **- O(n+m)**
* [Longest Common Prefix (LCP) array](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/LongestCommonPrefixArray.java) **- O(nlog(n)) bounded by SA construction, otherwise O(n)**
* [Longest Common Substring (LCS)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/LongestCommonSubstring.java) **- O(nlog(n)) bounded by SA construction, otherwise O(n)**
* [Longest Repeated Substring (LRS)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/LongestRepeatedSubstring.java) **- O(nlog(n))**
* [Manacher's algorithm (finds all palindromes in text)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/ManachersAlgorithm.java) **- O(n)**
* [Rabin-Karp algorithm (finds pattern matches in text)](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/RabinKarp.java) **- O(n+m)**
* [Substring verification with suffix array](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/strings/SubstringVerificationSuffixArray.java) **- O(nlog(n)) SA construction and O(mlog(n)) per query**

# Contributing

This repository is contribution friendly :smiley:. If you're an algorithms enthusiast (like me!) and want to add or improve an algorithm your contribution is welcome! Please be sure to include tests :kissing_heart:.

# For developers

This project uses [Gradle](https://gradle.org/) as a build system and for testing. To get started install the gradle command-line tool and run the build command to make sure you don't get any errors:

```bash
Algorithms$ gradle build
```

### Adding a new algorithm

The procedure to add a new algorithm named **Foo** is the following:

1) Identify the category folder your algorithm belongs to. For example a matrix multiplication snippet would belong to the com/williamfiset/algorithms/linearalgebra folder. You may also create a new category folder if appropriate.
2) Add the algorithm implementation to com/williamfiset/algorithms/category/ as com/williamfiset/algorithms/category/Foo.java
3) Add tests for Foo in javatests/com/williamfiset/algorithms/category/FooTest.java
4) Edit the **build.gradle** file if you added a new category to the project.
5) Test your algorithm thoroughly.
6) Send pull request for review :open_mouth:

### Testing

This repository places a large emphasis on good testing practice to ensure that published algorithms are bug free and high quality. Testing is done using a combinations of frameworks including: [JUnit](http://junit.org/junit4/), [Mockito](http://site.mockito.org/) and the [Google Truth](http://google.github.io/truth) framework. Currently very few algorithms have tests because they were (informally) tested against problems on [Kattis](https://open.kattis.com/problems) in a competitive programming setting, but we are slowly migrating to formally testing these algorithms for robustness.

When developing you likely do not want to run all tests but only a subset of them. For example, if you want to run the FloydWarshallTest.java file under [javatests/com/williamfiset/algorithms/graphtheory/FloydWarshallSolverTest.java](https://github.com/williamfiset/Algorithms/blob/master/com/williamfiset/algorithms/GraphTheory/tests/FloydWarshallSolverTest.java) you can execute:
```bash
Algorithms$ gradle test --tests "javatests.com.williamfiset.algorithms.graphtheory.FloydWarshallSolverTest"
# or simply run all the tests:
Algorithms$ gradle test
```

# License

This repository is released under the [MIT license](https://opensource.org/licenses/MIT). In short, this means you are free to use this software in any personal, open-source or commercial projects. Attribution is optional but appreciated.
